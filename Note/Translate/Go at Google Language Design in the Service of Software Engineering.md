1. Abstract

2. Introduction

3. Go at Google

4. Pain points 痛点

当Go 发布的时候，一些人声称Go缺少被认为是现代语言的必要特征和方法。如果没有这些设施，Go怎么可能值得？我们的答案是：Go确实解决了使大规模软件开发变得困难的问题。这些问题包括:

slow builds 慢的编译
  
uncontrolled dependencies 不可控制的依赖
  
each programmer using a different subset of the language  每个程序员使用不同语言的子集

poor program understanding(code hard to read,poorly documented,and so on) 难以理解的程序(代码不容易阅读，文档记录不当，等等)

duplication of effort 重复劳动

cost of updates 更新费用

version skew 版本倾斜

difficulty of writing automatic tools 很难编写自动化工具

cross-language builds 跨语言构建

语言的各个特征无法解决这些问题. 需要更大的软件工程视图，在Go的设计中，我们试图关注这些问题的解决方案。

作为一个简单，自我包含的例子，考虑程序结构的代表性。一些观察者反对使用大括号的Go的C-like块结构，更喜欢使用空格作为缩进，更喜欢使用Ptyhon或Haskell风格的缩进空格. 然而，我们在跟踪由跨语言构建引起的构建和测试失败方面有丰富的经验，其中嵌入在另一种语言中的Ptyhon片段，例如通过SWIG调用，被周围代码缩进的变化巧妙和无形地破幻着。我们的定位就在这里，尽快缩小的空间对于小程序来说很好， 在大规模的情况下，它没有那么好，并且越大和混合的代码库，它引起的麻烦越大。最好为了安全性和可扩展性放弃便利性，所以Go有大括号包围的代码块。

5. Dependencies in C and C++ C和C++中的依赖关系

在处理包依赖的时候出现了关于扩展和其他问题更实际的说明。我们开始讨论它们是怎么在C和C++上面工作的

ANSI C于1989年首次标准化，在标准头文件中推广了ifndef"guards" 的概念。现在普遍存在的思想是,每个头文件都用一个条件编译子句包括起来，这样文件可以被包含多次而不会出错。如unix头文件<sys/stat.h>的示意图如下:

```
/* Large copyright and licensing notice */
#ifndef _SYS_STAT_H_
#define _SYS_STAT_H_
/* Types and other definitions */
#endif
```
其目的是C预处理器读取文件，但忽略文件第二次和后续读取的文件内容。符号_SYS_STAT_H,第一次读取的时候定义，守护随后的调用

这个设计有一些很好的属性，最重要的是每个头文件可以安全的包含所有的依赖，即使其他的文件也会包含它们。如果遵循这个规则，它允许有序的代码，如，按字母顺序对include子句进行排序

但它的规模非常严重

1984年，在完成所有预处理时，观察到ps.c的汇编,Unix 中ps命令的源代码，引入<sys.stat.h>文件37次。即使内容在执行操作时被丢弃36次，大多数C实现也会打开文件，读取并扫描37次。事实上，没有很好的聪明，C预处理器的潜在复杂宏语义就需要这种行为。

对软件的影响是C程序中#include子句的逐渐积累。它不会破坏添加它们的程序，很难知道什么时候不再需要他们。删除一个#include 并且再一次编译这个程序不足以充分的测试它，因为其他的#include 可能包含一个#include来提取它。

从技术上来讲，它不一定是那样的。意识到通过使用#ifndef引起的长期问题，Plan9库的设计者采用了不同的，non-ANSI 标准的方法。在Plan9中，头文件被禁止包含其他的#include 子句，所有的#include 子句必须在顶级C文件中。当然，这需要一些规则，程序员们被要求这个要求一些，当然，这个程序被要求一次性的按照正确顺序列出必要的依赖项。在文档的帮助和实践下它工作的很好。这个结果表明:无论一个C源文件有多少依赖项，在编译该文件时，每个include文件都只读取一次。当然，通过去掉一个include也很容易看出它是否是必要的，如果并且仅当依赖是不必要的时候，被编辑的程序才会编译。


Plan9方法中最重要的结果就是加快了编译速度，编译需要要的I/O数量远远少于使用#ifndef编译程序的程序。

然而，在Plan9之外，这个"guarded"方法是C和C++的公认实践。事实上，C++在细粒度上使用相同的方法加剧了这个问题。按照惯例，C++程序通常每个类都有一个头文件，或者可能是一组相关的小类，一个分组要比<stdio.h>来说要小。因此，依赖树更加复杂，反应的不是库依赖，而是完整的类型层次结构。此外，C++头文件通常包含真正的代码类型、方法和模板声明，而不仅仅是C头文件典型的简单常量和函数签名。因此，C++不仅向编译器推得更多，它所推动的也更难编译，并且编译器的每次调用都必须重新处理这些信息。在构建大型的C++二进制文件时，编译器可能会被教授数千次如何通过处理头文件<string>来表示字符串。(据记载，1984年左右，Tom Cargil 观察到使用C预处理器进行依赖管理将是C++的责任，应予以解决.）

在Google一个单独的C++的组成可以打开和阅读成千个单独的头文件很多次。在2007年，谷歌的编译工程师发表了对Google一个主要二进制文件的抱怨。这个文件包含了大概两千个文件，如果仅仅是在一起，总共4.2 megabytes. 随着时间这个#include 被扩大，超过8 gigabytes 被分发到输出的编译器或者，每个c++源文件 a blow-up 2000 bytes.如果简单的连接在一起，总计4.2兆字节。当扩展#include的时候，超过8千兆字节被传送到编译器的输入，每个C++源字节爆发2000字节。

作为另一个数据节点，2003谷歌的构建系统从当个Makefile文件转移到具有更好管理，更明确的依赖关系的每个目录设计。典型的二进制文件缩小了大约40%在大小上，只是记录了更准确的依赖项。即便如此，C++(或C语言)的属性使得自动验证这些依赖关系变得不切实际，并且今天我们让然无法准确理解大型Googel C++二进制文件的依赖性要求。

这些不受控制的依赖性和大规模的结果是在单个计算机上构建Google服务器的二进制文件时不切实际的，因此创建了一个大型分布式编译系统。有了这个系统，设计了很多机器，很多缓存和很多复杂性（构建系统本身就是一个大型程序），谷歌的构建虽然仍然很麻烦，但却很实用。

尽快使用分布式构建系统，大型的Googel构建仍然需要很长时间。使用前体分布式构建系统，2007二进制文件需要45分钟，今天的版本同一个程序需要27分钟，但当然程序及其依赖性在过渡期间已经增长。扩展构建系统所需的工程工作几乎无法保持领先于正在构建的软件的增长。


6. Enter GO

当构建缓慢时，有时间思考。Go的起源神话表明，正是在这45分钟构建中，构思了GO。人们认为值得尝试设计一种适合编写大型Google程序(如Web服务器）的新语言，其软件工程考虑因素可以提高Google工程师的生活质量。

虽然到目前为止的讨论都集中在依赖性，但还有很多其他问题需要注意。任何语言成功的主要考虑因素是:


它必须大规模地工作，对于具有大量依赖性的大型程序，以及大型工程师的团队。

它必须熟悉，大致类似于C。在谷歌工作的程序员在职业生涯的早期阶段，最熟悉程序语言，尤其是来自C家族的程序语言。使程序员以新语言快速生产的需要意味着语言不能过于激进。


尽快这个讨论很久关注到依赖管理上面，同时还有很多问题需要关注。对于任何一门成功语言主要的考虑因素在文章中是:

它必须工作在大规模，大型的项目使用大量数目的依赖管理，可以大型团队工程师工作在上面。

它可以被熟悉的，C周围和C比较像的。工程师工作在Google在他们的职业生涯中，大多熟悉这些慢慢产生的语言，特别是C家族的。需要很快地获取产品化的程序在一个新的语言中意味着这个语言不能

它必须是现代的。C、C++，在某种程度上，Java是相当陈旧的，在多核机器，网络和web应用程序开发出现之前设计的。现代世界的某些功能可以通过更新的方法更好地满足，例如内置并发。

扩展的Java都有一点老，这些设计在多核机器之前，网络，web 客户端开发。有很多现代社会中的特性被合理的解决通过新的方法，例如内置并发。

有了这样的背景，让我们从软件工程的角度来看看Go的设计。

7. Dependencies in Go
既然我们已经详细了解了C和C++的依赖管理，那么开始我们的旅程的一个好地方就是看看Go如何处理它们的。依赖关系是语言在语法和语义上定义的。他们是明确的，清晰地，可计算的，也就是说，易于编写分析工具。

语法是，在package字符之后(下一节的主题)，每个源文件可能有一个或者多个import语句，包含import关键字和一个字符串常亮，用于标识要导入源文件的包(仅限):

```
import "encoding/json"
```

制定Go scale(依赖性)的第一步是语言定义未使用的依赖项是编译错误(不是警告，是错误)。如果源文件导入它不适用的包，则程序将无法编译。这通过构造保证任何Go程序的依赖树是精确的，它没有无关的边缘。反过来，这可以保证在构建程序时不会编译额外的代码，从而最大限度地缩短编译时间。

还要另外一个步骤，这次是编译器的时间，甚至可以进一步保证效率。考虑一个带有三个包和这个依赖图的Go程序。

package A 引入 package B
package B 引入 package C
package A 没有引入 package C.


这意味着包A仅通过使用B来传递使用C，也就是 说，在A的源代码中没有提到来自C的标识符，即使A中使用某些项提到了C。例如，包A可能引用在B中定义的具有字段的结构类型，该结构类型具有在C中定义的类型，但A不引用自身。作为一个激励人心的例子，假设A导入一个格式化的I/O包B，它使用C提供的缓存I/O实现，但A本身并不调用缓存I/O.

要构建这个程序，首先要编译C，依赖的包必须在依赖它们的包之前构建。然后B被编译，最后A被编译，然后程序可以被链接。

编译A时，编译器读取B的对象文件，而不是其源代码。B的对象文件包含编译器执行所需的所有类型信息

```
import B
```

在A的源代码的字句中。该信息包括B的客户端在编译时需要的关于C的任何信息。换句话说，在编译B时，生成的对象文件包含影响B的公共接口的B的所有依赖项的类型信息。

这种设计具有如下重要的影响：当编译器执行import字句时，它只打开一个文件，即由导入导入字句中的字符串标识的对象文件。当然，这让人想起Plan9C（而不是ANSI C)的依赖管理方法，但实际上，编译器在编译的Go源文件的时会写入源文件。但是这个过程比Plan9更自动化，更高效。在评估导入时读取的数据只是导出的数据，而不是一般的程序源代码。对整个编译时间的影响可能是巨大的，并且随着基础代码库的增大而扩展。执行依赖图并因此编译的时间可以比C和C++包含文件模型中的指数小。

值得一提的是，这种构建依赖管理的方法并不是原创的，这个想法可以追溯到20世纪70年代，并通过诸如像Modula-2和Ada之类的语言传播.在C家族中，Java具有这种方法的元素。

为了使编译更加的高效，对对象文件进行了安排，以便导出数据是文件中的第一件事，这样编译器可以在到达该节末尾时立即停止读取。

这种依赖管理的方法是Go编译比C和C++编译更快的唯一最大原因。另一哥因素是Go将导出的数据放在对象文件中，某些语言要求作者编写或编译器生成包含信息的第二个文件。打开的文件是打开的两倍。在Go中，只有一个文件可以打开以导入包。此外，单文件方法意味着导出数据（头文件，C/C++）相对于对象文件永远不会过时。

为了记录，我们测量了用GO编写的大型Googel程序的编译，一了解代码扇出与之前完成的C++分析相比如何。我们发现它大约是40倍，比C++好出50倍（并且简单，因此处理速度更快），但它仍然比我们预期的要大。有两个原因，首先我们发现了一个BUG,Go编译器在导出部分生成了大量数据而不需要在哪里。其次，导出数据使用可以改进的详细编码。我们计划解决这些问题。

尽快如此，一个少于50分钟的因素会把分钟变成秒，咖啡会变成互动构建。

Go依赖图的另一个重要特性是它没有循环。该语言定义图中不能有循环导入编译器和链接器都会检查他们是否存在。虽然他们偶尔会有用，但引入循环会引起大规模的重大问题。他们要求编译器同时处理更大的源文件集，这会减慢增量构建。更重要的是，在我们的经验允许下，这些导入最终会将源代码树的大量内容缠绕成难以独立管理的大型子项目，使二进制文件膨胀，并使初始化、测试、重构、发布和其他软件开
发任务复杂化。

缺乏循环导入会导致偶尔的麻烦，但会保持树的清洁，迫使在包之间进行明确的划分。与Go中许多设计决策一样，它迫使成程序员更早地考虑一个更大的问题。（在本例中是包边界），如果留到以后再考虑，可能永远不会得到令人满意的解决。

通过标准库的设计，花费了很大精力来控制依赖关系。复制一些代码比为了一个函数拉入一个大型库更好。（如果出现新的核心依赖关系，系统构建中的测试会抱怨），依赖性卫生胜过代码重用。实践中的一个例子是（低级）网络包具有其自己整数到十进制的转换例程，以避免依赖于较大且依赖性较大的格式化I/O包。另一个是字符串转换包strconv具有printable字符定义的私有实现，而不是拉入大的Unicode字符类表，strconv尊重Unicode标准由包的测试验证。



























