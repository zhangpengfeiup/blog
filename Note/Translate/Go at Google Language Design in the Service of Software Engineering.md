1. Abstract

2. Introduction

3. Go at Google

4. Pain points 痛点

当Go 发布的时候，一些人声称Go缺少被认为是现代语言的必要特征和方法。如果没有这些设施，Go怎么可能值得？我们的答案是：Go确实解决了使大规模软件开发变得困难的问题。这些问题包括:

slow builds 慢的编译
  
uncontrolled dependencies 不可控制的依赖
  
each programmer using a different subset of the language  每个程序员使用不同语言的子集

poor program understanding(code hard to read,poorly documented,and so on) 难以理解的程序(代码不容易阅读，文档记录不当，等等)

duplication of effort 重复劳动

cost of updates 更新费用

version skew 版本倾斜

difficulty of writing automatic tools 很难编写自动化工具

cross-language builds 跨语言构建

语言的各个特征无法解决这些问题. 需要更大的软件工程视图，在Go的设计中，我们试图关注这些问题的解决方案。

作为一个简单，自我包含的例子，考虑程序结构的代表性。一些观察者反对使用大括号的Go的C-like块结构，更喜欢使用空格作为缩进，更喜欢使用Ptyhon或Haskell风格的缩进空格. 然而，我们在跟踪由跨语言构建引起的构建和测试失败方面有丰富的经验，其中嵌入在另一种语言中的Ptyhon片段，例如通过SWIG调用，被周围代码缩进的变化巧妙和无形地破幻着。我们的定位就在这里，尽快缩小的空间对于小程序来说很好， 在大规模的情况下，它没有那么好，并且越大和混合的代码库，它引起的麻烦越大。最好为了安全性和可扩展性放弃便利性，所以Go有大括号包围的代码块。

5. Dependencies in C and C++ C和C++中的依赖关系

在处理包依赖的时候出现了关于扩展和其他问题更实际的说明。我们开始讨论它们是怎么在C和C++上面工作的

ANSI C于1989年首次标准化，在标准头文件中推广了ifndef"guards" 的概念。现在普遍存在的思想是,每个头文件都用一个条件编译子句包括起来，这样文件可以被包含多次而不会出错。如unix头文件<sys/stat.h>的示意图如下:

```
/* Large copyright and licensing notice */
#ifndef _SYS_STAT_H_
#define _SYS_STAT_H_
/* Types and other definitions */
#endif
```
其目的是C预处理器读取文件，但忽略文件第二次和后续读取的文件内容。符号_SYS_STAT_H,第一次读取的时候定义，守护随后的调用

这个设计有一些很好的属性，最重要的是每个头文件可以安全的包含所有的依赖，即使其他的文件也会包含它们。如果遵循这个规则，它允许有序的代码，如，按字母顺序对include子句进行排序

但它的规模非常严重

1984年，在完成所有预处理时，观察到ps.c的汇编,Unix 中ps命令的源代码，引入<sys.stat.h>文件37次。即使内容在执行操作时被丢弃36次，大多数C实现也会打开文件，读取并扫描37次。事实上，没有很好的聪明，C预处理器的潜在复杂宏语义就需要这种行为。

对软件的影响是C程序中#include子句的逐渐积累。它不会破坏添加它们的程序，很难知道什么时候不再需要他们。删除一个#include 并且再一次编译这个程序不足以充分的测试它，因为其他的#include 可能包含一个#include来提取它。

从技术上来讲，它不一定是那样的。意识到通过使用#ifndef引起的长期问题，Plan9库的设计者采用了不同的，non-ANSI 标准的方法。在Plan9中，头文件被禁止包含其他的#include 子句，所有的#include 子句必须在顶级C文件中。当然，这需要一些规则，程序员们被要求这个要求一些，当然，这个程序被要求一次性的按照正确顺序列出必要的依赖项。在文档的帮助和实践下它工作的很好。这个结果表明:无论一个C源文件有多少依赖项，在编译该文件时，每个include文件都只读取一次。当然，通过去掉一个include也很容易看出它是否是必要的，如果并且仅当依赖是不必要的时候，被编辑的程序才会编译。


Plan9方法中最重要的结果就是加快了编译速度，编译需要要的I/O数量远远少于使用#ifndef编译程序的程序。

然而，在Plan9之外，这个"guarded"方法是C和C++的公认实践。事实上，C++在细粒度上使用相同的方法加剧了这个问题。按照惯例，C++程序通常每个类都有一个头文件，或者可能是一组相关的小类，一个分组要比<stdio.h>来说要小。因此，依赖树更加复杂，反应的不是库依赖，而是完整的类型层次结构。此外，C++头文件通常包含真正的代码类型、方法和模板声明，而不仅仅是C头文件典型的简单常量和函数签名。因此，C++不仅向编译器推得更多，它所推动的也更难编译，并且编译器的每次调用都必须重新处理这些信息。在构建大型的C++二进制文件时，编译器可能会被教授数千次如何通过处理头文件<string>来表示字符串。(据记载，1984年左右，Tom Cargil 观察到使用C预处理器进行依赖管理将是C++的责任，应予以解决.）

在Google一个单独的C++的组成可以打开和阅读成千个单独的头文件很多次。在2007年，谷歌的编译工程师发表了对Google一个主要二进制文件的抱怨。这个文件包含了大概两千个文件，如果仅仅是在一起，总共4.2 megabytes. 随着时间这个#include 被扩大，超过8 gigabytes 被分发到输出的编译器或者，每个c++源文件 a blow-up 2000 bytes.如果简单的连接在一起，总计4.2兆字节。当扩展#include的时候，超过8千兆字节被传送到编译器的输入，每个C++源字节爆发2000字节。

作为另一个数据节点，2003谷歌的构建系统从当个Makefile文件转移到具有更好管理，更明确的依赖关系的每个目录设计。典型的二进制文件缩小了大约40%在大小上，只是记录了更准确的依赖项。即便如此，C++(或C语言)的属性使得自动验证这些依赖关系变得不切实际，并且今天我们让然无法准确理解大型Googel C++二进制文件的依赖性要求。

这些不受控制的依赖性和大规模的结果是在单个计算机上构建Google服务器的二进制文件时不切实际的，因此创建了一个大型分布式编译系统。有了这个系统，设计了很多机器，很多缓存和很多复杂性（构建系统本身就是一个大型程序），谷歌的构建虽然仍然很麻烦，但却很实用。

尽快使用分布式构建系统，大型的Googel构建仍然需要很长时间。使用前体分布式构建系统，2007二进制文件需要45分钟，今天的版本同一个程序需要27分钟，但当然程序及其依赖性在过渡期间已经增长。扩展构建系统所需的工程工作几乎无法保持领先于正在构建的软件的增长。


6. Enter GO

当构建缓慢时，有时间思考。Go的起源神话表明，正是在这45分钟构建中，构思了GO。人们认为值得尝试设计一种适合编写大型Google程序(如Web服务器）的新语言，其软件工程考虑因素可以提高Google工程师的生活质量。

虽然到目前为止的讨论都集中在依赖性，但还有很多其他问题需要注意。任何语言成功的主要考虑因素是:


它必须大规模地工作，对于具有大量依赖性的大型程序，以及大型工程师的团队。

它必须熟悉，大致类似于C。在谷歌工作的程序员在职业生涯的早期阶段，最熟悉程序语言，尤其是来自C家族的程序语言。使程序员以新语言快速生产的需要意味着语言不能过于激进。


尽快这个讨论很久关注到依赖管理上面，同时还有很多问题需要关注。对于任何一门成功语言主要的考虑因素在文章中是:

它必须工作在大规模，大型的项目使用大量数目的依赖管理，可以大型团队工程师工作在上面。

它可以被熟悉的，C周围和C比较像的。工程师工作在Google在他们的职业生涯中，大多熟悉这些慢慢产生的语言，特别是C家族的。需要很快地获取产品化的程序在一个新的语言中意味着这个语言不能

它必须是现代的。C、C++，在某种程度上，Java是相当陈旧的，在多核机器，网络和web应用程序开发出现之前设计的。现代世界的某些功能可以通过更新的方法更好地满足，例如内置并发。

扩展的Java都有一点老，这些设计在多核机器之前，网络，web 客户端开发。有很多现代社会中的特性被合理的解决通过新的方法，例如内置并发。

有了这样的背景，让我们从软件工程的角度来看看Go的设计。

7. Dependencies in Go



































