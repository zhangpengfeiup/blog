Shell scripts: shell脚本学习


#### 为什么学习shell script
 
- 自动化管理：查询登录、追踪流量、监控使用者使用主机状态、主机各项硬件设备状态、主机软件升级查询蹬

-  追踪与管理系统的重要工作

- 简单入侵检测功能

- 连续命令单一化

- 简单的数据处理

-跨平台支持

- 可以去路径/etc/init.d/ 下面看一下文件的内容，发现里面都是shell写的


#### 注意事项：

1. 命令的运行时从上而下、从左而右的分析与运行

2. 命令、选项与参数间的多个空白都会被忽略掉

3. 空白行也将被忽略掉，并且[tab]按键所推开的空白同样视为空白键

4. 如果读取到一个Enter符号，就尝试开始运行该行命令

5. 至于如果一行的内容太多，则可以使用[\Enter]来延伸至下一行

6.  '#'可以作为注释，任何加在#后面的数据将全部被视为注释文字而被忽略！


#### 善用判断式

- 利用test命令的测试功能

test 命令可以判断文档文档是否存在/文档类型/文档的权限信息/对比两个文件/两个正数之间的判断/判断是否为字符串/多重条件判断

- 中括号中的与和或判断条件

```  
[ "$yn" != "yes" -a "$yn" != "YES" ] 
```

语句表示: $yn 不等于yes 且不等于YES 的时候

```
[ "$yn" == "yes" -o "$yn" == "YES" ]
```

 语句表示: $yn 等于yes 或者 $yn 等于YES的时候
 
- case ...... esac 判断

```

case  $变量名称 in   <==关键字为 case ，还有变量前有钱字号
  "第一个变量内容")   <==每个变量内容建议用双引号括起来，关键字则为小括号 )
	程序段
	;;            <==每个类别结尾使用两个连续的分号来处理！
  "第二个变量内容")
	程序段
	;;
  *)                  <==最后一个变量内容都会用 * 来代表所有其他值
	不包含第一个变量内容与第二个变量内容的其他程序运行段
	exit 1
	;;
esac                  <==最终的 case 结尾！『反过来写』思考一下！

```

- shell script 的追踪与 debug

```
   sh [-nvx] scripts.sh
   -n : 不要运行script,仅查询语法的问题；
   -v : 再运行script前，先将scripts的内容输出到荧幕上;
   -x : 将使用到的script内容显示到荧幕上，这是很有用的参数!
```
- 计算处理 推荐val=$((运算内容))

例子:
```

 #!/bin/bash

va=`expr 3 + 3`

val=$((1+2))

echo $val

echo "两数之和为 : $va"	 
```



#### 重点回顾
- shell script 是利用shell的功能所写的一个[程序(program)],这个程序是使用纯文字档，将一些shell的语法与命令(含外部命令)写在里面，搭配正规表示法、管线命令与数据流重导向等功能，以达到我们所想要的处理目的

- shell script 是用在系统管理上面很好的一项工具，但是用在处理大量数值运算上，就不够好了， 因为Shell scripts 的速度较慢，且使用的CPU资源较多，造成主机资源的分配不良.

- 在shell script 的文件中，命令的运行是从上而下、从左而右的分析与运行

- 良好的程序撰写习惯中，第一行要宣告(#!/bin/bash),第二行以后则宣告程序用途、版本、作者等

- 对谈式(互动/交流式)脚本可以使用read 命令达成

- 要创建每次运行脚本都有不同结果的数据，可使用 date 命令利用日期达成

- script 的运行若以 source 来运行时，代表在父程序的bash内运行之意

- 若需要进行判断式，可使用test 或 中括号 ([]) 来处理

- 在 script 内，$0,$1,$2...,$@ 是有特殊意义的

- 条件判断式可使用if ... then 来判断，若是固定变量内容的情况下，可使用case $var in ... esac 来处理.

- 回圈(也就是循环),主要分为不定回圈 (while,until) 以及固定回圈 (for),配合do,done 来达成所需任务!

- 可以使用sh -x script.sh 来进行程序的 debug 

